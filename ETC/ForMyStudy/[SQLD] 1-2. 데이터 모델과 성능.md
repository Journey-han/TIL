# 2장. 데이터 모델과 성능

## 1절. 성능 데이터 모델링의 개요 

### 1. 성능 데이터 모델링
- DB 성능 향상을 위한 사항이 데이터 모델링에 반영되도록 하는 것.

### 2. 수행 시점
- 분석/설계 단계. 성능 데이터 모델링 시점이 늦어질수록 재업무 비용이 증가

### 3. 성능 데이터 모델링의 고려사항 순서
1. 데이터 모델링을 할 떄 정규화를 정확하게 수행
2. DB **용량산정**을 수행
3. DB에 발생되는 **트랜잭션의 유형 파악**
4. 용량과 트랜잭션의 유형에 따라 **반정규화** 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼/서브타임 조정
6. 성능관점에서 데이터 모델을 **검증**

## 2절. 정규화와 성능

### 1. 정규화
- 데이터 분해 과정. **이상현상 제거**


> 💡 정규형(NF) : 정규화로 도출된 데이터 모델이 갖춰야 할 특성


### 2. 함수적 종속성
- 결정자와 종속자의 관계, 결정자의 값으로 종속자의 값을 알 수 있다.

### 3. 정규화 이론
- 제 1차 정규화 : **도메인이 원자값으로** 이루어지도록 함. **중복의 속성을 분리**
- 제 2차 정규화 : **부분 함수 종속 제거** 어떤 속성 Y가 다른 복합 속성 X의 부분집합에 종속하는 관계
    - 기본키가 복합키로 구성되어 있을 떄(기본키가 여러 개) 복합키 전체에 의존하지 않고 일부에 의존적인 열이 있으면 이를 제거. _부분의존 제거 = 2차 정규화_
- 제 3차 정규화 : **이행 함수 종속 제거**. X -> Y이고 Y -> Z일 때 X -> Z를 이끌어 낼 수 있는 관계
- BCNF(보이스코드) : **결정자가 아닌 후보키가 없도록**
- 제 4차 정규화 : **다치 종속 제거**. 여러 컬럼이 동일한 결정자의 종속자인 경우
- 제 5차 정규화 : **조인 종속 제거**

### 4. 정규화와 성능
- 정규화로 인한 성능 향상 : 입력 / 수정 / 삭제 시 성능은 항상 향상된다.
    - 유연성 증가. 재활용 가능성 증가(개념의 세분화). 데이터 중복 최소화
- 성능 저하 : 조회 시 처리 조건에 따라 성능 저하 발생 가능성 O
    - 반졍규화로 해결 가능
    - 조인 발생 -> 인덱스를 사용하여 조인연산 수행 시 성능상 단점 거의 X.
    - 정규화를 통해 소량의 테이블이 생성된다면 성능상 유리할 수 있다.

## 3절. 반정규화와 성능

### 1. 반정규화
- **데이터 중복을 허용하여 조인을 줄이는 DB 성능 향상 방법.** 데이터의 무결성을 희생하고 조회 성능 향상

### 2. 절차
1. 반정규화 대상 조사 : 데이터 처리 범위 및 통계성 등 조사
2. 다른 방법 검토 : 뷰, 클러스터링, 인덱스 조정
3. 반정규화 적용 : 정규화 수행 후 반정규화 수행 (테이블, 속성, 관계 반정규화)

### 3. 기법
- 테이블 반정규화
    1. 테이블 병합
        - 1:1 관계 테이블 병합
        - 1:N 관계 테이블 병합(많은 데이터 중복 발생)
        - 슈퍼타입 / 서브타입 테이블 병합
    2. 테이블 분할
        - 수직분할 : 컬럼 단위로 테이블을 분할하여 I/O 감소시킴. 너무 많은 수의 컬럼이 있는 경우 사용한한다.
        - 수평분할 : 행 단위로 테이블을 분할하여 I/O 감소시킴.
    3. 테이블 추가
        - 중복 테이블 : **업무나 서버가 다를 때** 중복 테이블 생성 (원격조인 제거)
        - 통계 테이블 : SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능 향상
        - 이력 테이블 : 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
        - 부분 테이블 : **자주 이용하는 컬럼으로 구성된 테이블 생성**
- 컬럼 반정규화
    1. 중복 컬럼 추가 : 조인에 처리할 떄 성능저하를 예방하기 위해 중복된 컬럼을 위치 시킴.
    2. 파생 컬럼 추가 : 필요한 값 미리 계산한 컬럼 추가
    3. 이력 테이블 컬럼 추가 : 대량의 이력데이터 처리 시 불특정한 날 또한 최근 값 조회할 때 나타날 수 있는 성능 저하 예방 -> 기능성 컬럼 추가(최근값 여부, 시작/종료일자 등)
    4. PK에 의한 컬럼 추가 :  PK의 종속자를 일반속성으로 생성.
    5. 응용 시스템의 오작동을 위한 컬럼 추가 : 업무적으로 의미X. 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
- 관계 반정규화 : 데이터 무결성 보장 가능
    1. 중복 관계 추가

## 4절. 대용량 데이터에 따른 성능
- 테이블 반졍규화 [테이블 분할 관련]

### 1. 블록
- 테이블의 데이터 저장 단위

### 2. 대량 데이터 발생으로 인한 현상
- 블록 I/O 횟수 증가 -> 디스크 I/O 가능성 상승 (성능 저하)


1. 로우 체이닝(Row Chaining) : 행 길이가 너무 길어 여러 블록에 걸쳐 저장되는 현상
2. 로우 마이그레이션(Row Migration) : 수정된 데이터가 해당 블록이 아닌 다른 블록의 빈공간에 저장되는 현상

### 3. 피티셔닝(Partitioning)
- 테이블 수평분할 기법. 논리적으로는 하나의 테이블이지만 물리적으로 여러 데이터 파일에 분산 저장
- 데이터 조회 범위를 줄여 성능 향상


1. Range Partition : 데이터 값의 범위를 기준으로 분할
2. List Partition : 특정한 값을 기준으로 분할
3. Hash Partition : 해시 함수를 적용하여 분할. DBMS가 알아서 분할관리. 데이터 위치 알 수 없다.
4. Composite Partition : 여러 파티션 기법을 복합적으로 사용하여 분할


> 💡 파티션 인덱스(Partiton Index)    
> - Global Index, Local Index : 여러 파티션에서 단일 인덱스 사용. 파티션 별로 각자 인덱스 사용.    
> - Prefixed Index, Non-Prefixed Index : 파티션키와 인덱스키 동일. 파티션키와 인덱스키 구분.    


### 4. 테이블에 대한 수평 / 수직 분할 절차
1. 데이터 모델링 **완성**
2. 데이터 베이스 **용량산정**
3. 대량 데이터가 처리되는 테이블에 대해 **트랜잭션 처리 패턴 분석**
4. 컬럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생되는지 분석 -> **집중화된 단위로 테이블 분리를 검토**

## 5절. 데이터베이스 구조와 성능

### 1. 슈퍼타입 / 서브타입 모델
- 속성을 할당하여 배치하는 수평 분할된 형태의 모델
- **공통속성 = 슈퍼타입, 차이가 있는 속성 = 서브타입**으로 모델링
- 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있는 장점을 가짐.
- **논리적인 데이터 모델에서 이용되는 형태**
- 분석 단계에서 많이 쓰이는 모델

### 2. 슈퍼 / 서브타입 데이터 모델의 변환 (🥨)
- 슈퍼 / 서브 타입 변환 시 성능저하 발생 가능성
    1. 트랜잭션은 항상 **일괄로 처리하는데 테이블은 개별로 유지**되어 **Union연산에 의해 성능 저하 가능성**이 있다.
    2. 트랜잭션은 항상 **서브타입 개별로 처리하는데 테이블은 하나로 통합되어**있어 **불필요하게 많은 양의 데이터가 집약되어 있어 성능 저하 가능성**이 있다.
    3. 트랜잭션은 항상 **슈퍼 + 서브 타입을 공통으로 처리**하는데 **개별로 유지되어 있꺼나 하나의 테이블로 집약되어 있어 성능 저하**되는 경우가 존재한다. -> _조인에 의한 성능 저하_
- 슈퍼 / 서브 타입 변환 기준
    1. 데이터 양
    2. 트랜잭션의 유형

### 3. 슈퍼 / 서브 타입 데이터 모델의 변환 기술
1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성(OneToOne Type)
2. 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입 + 서브타입 테이블로 구성(Plus Type)
3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성(Single Type, All In One Type)


| 구분 | OneToOne Type | Plus Type | Single Type |
| :---: | :--- : | :---: | :---: |
| **특징** | 개별 테이블 유지 | 슈퍼 + 서브타입 테이블 | 하나의 테이블 |
| **확장성** | 우수함 | 보통 | 나쁨 |
| **조인성능** | 나쁨 | 나쁨 | 우수함 |
| **I/O량 성능** | 좋음 | 좋음 | 나쁨 |
| **관리용이성** | 좋지않음 | 좋지않음 | 좋음(1개) |
| **트랜잭션 유행에 따른 선택 방법**| 개별 테이블로 접근이 많은 경우 선택 | 슈퍼+서브 형식으로 데이터를 처리하는 경우 선택 | 전체를 일괄적으로 처리하는 경우 선택 |


4. PK/FK 컬럼 순서로 조절을 통한 성능 향상
    - 등호 조건이나 BETWEEN 조건이 걸리는 컬럼을 앞으로 이동 (여러 조건이 있을 경우 등호 조건이 걸리는 컬럼을 선두로 이동)
5. 인덱스 특성을 고려한 PK/FK DB 성능 향상
    - 물리적인 테이블에 FK 제약을 걸어 인덱스를 생성

## 6절. 분산 데이터베이스와 성능
